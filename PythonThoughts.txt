
My Thoughts On Areas Of Python
------------------------------

------------------
Lambda Expressions
------------------
	
	0. Introduction To The Function As A Unit Of Abstraction

	Functions do serve the immediate purpose of removing duplications in code, which is an extremely useful thing to do. When
	you remove duplications in code, it means that:
		1/ You reduce the size of the code base and the amount of code that has to be read to be understood
		2/ When changing functionality, you may now only have to change one section of code, and not multiple:
			2.1/ Changing multiple sections of code means that some sections might be missed
			2.2/ Changing multiple sections of code means that the changes might be inconsistent
			2.3/ It allows you to identify patterns and connections in functionality

	Functions also serve, however, as a unit of abstraction, that means we do not have to understand HOW the function works, to
	use it (such is the case with alot of API use). 

	A side effect in the creation of this 'abstraction' is that we have the ability to name this abstraction, and continue to
	refer to the abstraction by its name, which grants the oppertunity to add documentary and explanatory value to such names. 

		E.g Engine.speedUpByAmount(int AmountInMilesPerSecond)

	1. The Concept Of A Lambda Expression in Programming

	Lambda expressions are a more basic unit than functions, in that they can be used to the same effect in the Python programming
	language. 

		def myFuntion(integer):
			return (integer*2)

		myFunction = (lambda integer: (integer*2))

		now calling:
			myFunction(2)
		will incur the same result in both cases.

	2. The Gains Made Having The Lambda Expression in Python

	We have shown above that these expression can result in the same effect as usual functions in Python, so what do they add?

	The answer to this is the ability to have 'anonymous functions', or functions that we declare without naming them. There
	are such use cases for functions such as these:

		1/ Short, throwaway functions that will only be used once
		2/ Functions that we input into other functions
		3/ Inside functions that return other functions as the return value

----------
Exceptions
----------
*the order that we wrote that in was placeholders, then got the number of characters needed, then placed them

	0. Why We Need The Concept of Exceptions in Programming

	"If there is a way for code to break, someone, somewhere will break it".

	It is not enough just to program for the functional cases these days, since malicious programmers will find ways to use the
	code in ways that the original author of that code did not intend.

	Exceptional programming takes these instances of non-functional programming into account, and prepares contingencies for them.

	1. Error vs Exceptions

	Some programming languages do not have exception built in at the language level, and instead the user can program secure code
	using error return codes, and rollbacks.

	*Below I am taking advantage of a linguistic pattern, and i dont enough relevant voacbulary to describe these things accurately or succintly
	Such coding DOES achieve the same effect, however it is also use to have exceptions implemented as a seperate construct at the language,
	so that we can program for the exceptions cases and functional cases seperately. 

	This also makes it clear when reading the code bases which code is exceptional and which code is functional.

	2. Pythons Inbuilt Exception Language Level Constructs

		2.1 "Try"

		This construct is used for code that will potentially raise an exception during it's execution. Such a block also serves to inform
		the reader that this code contains exceptional circumstances, so if a refactoriing attempt is made, such considerations can be taken
		into account.

		2.2 "Except"

		This construct allows the user to catch different exceptions in a specified order. This construct is useful since we may have different
		exceptional circumstances that arise during a code blocks execution, for which:
			1/ We may want to treat differently based on criticalness, such as for some exceptions we may want to exit immediately
			2/ We may want to log certain exceptions differently, and under different logging levels
			3/ We may want to create tailored user messages for different exceptions
			4/ We may with to pass some errors further up the chain differently

		Note: the 'except' code also allows us to rollback if needed.

		2.3 "Else"

		This block is to be executed if the 'Try' block was executed successfully. This allows the programmer to write code blocks that are
		reliant on a certain section of code executing successfully, so as not to cause problems. 

		Such a clause also serves to document what code requires preconditions (that will be found in the associated try block), so that we
		can spot dependencies in code more easily aswell. 

		*Consistency allows for learning, spotting patterns, and ease of automatic processing
		2.4 "Finally"

		*neccessary duplication (in that the alternatives can only be worse for understanding (which is our objective))
		This block of code is executed if the whether or not the try block succeeds, so this code is used for code that is executed in 
		all cases, that is tied to the functionality of the try block.

		Since such code could simply be written after the code blocks above without being in a exception-vien block itself, using such
		a clause is more documentary value in expressing the intention and connection within code (using the language constructs in Python)


-------
LOGGING
-------
	
	0. Introduction To The Idea Of Logging

	"Logging is about reporting problems, and progress, during execution"

	Logging is there so that programmers (and testers) have a window into what is going on during execution, and can also easily obtain
	critical or just wanted information about aspects of the system while it is running.

	When code runs, usually we do not have easy access to what is happening internally, such as how parameters are changing, what is being
	called when, what is being create when etc. 

	Logging gives us the ability to tailor messages during execution to be stored to a file that can be read later to understand information
	about the execution of the system.

	1. Logging Levels

	Python's built-in logging module has included five levels of logging: [ Debug, Info, Warning, Error, Critical ]

	The reason why logging has been implemented with a concept of levels is that too much information to process can cause confusion, and
	raises the potential for human mistakes, since in general we will be relying on humans to interpret the logs. 

	Having different levels means that we can turn off and on logging in different circumstances for logging. For instance, during code
	development, we may be interested in all levels of logging messages, but in the production environment, we may only want the engineers
	to have to sift through and understand higher levels than debug for logging messages. 

	The level implementation is by not means perfect for all circumstances (although for most cases it seems useful as is), so Python
	also includes the ability to implement further levels tailored to your needs. 

	2. Including Logging In Code

	Two things are required before being able to use a logger.
		You need to call a function to:
		1/ Configure the logging
		2/ Retrieve the logger'
		*Allows for the much more effecient reading and storage of this information now...

	So the question becomes, where do we put such functions in our code in a way that isn't detrimental to life.

	The safest option is to:
		1/ Use the global logger
		2/ Include global code at the top of every module that retrieves the global logger, so that every module now has a copy 
		   of the logger to log messages during execution.

	At the present time, this is the only global code I find acceptable in a module. (This may change)

------------
Unit Testing
------------


	Their Test Function:

		radii = [1, 2, 0, -1, "Hello", 1 +2j]
		message = "We have test radii: {radius} and area: {area}"

		for r in radius:
			area = circle_area(r)
			print(message)

	What I think about thier test function:

		1/ The first problem is that they are relying on humans to interpret the result. This is just asking for problems
		2/ Who knows what the list of expected outcomes is? Why is this seperated from the code? This is just asking for this
		   this test code not to be used. 
		3/ There should also be automatic interpretation of result, because for a human then, testing a project could take
		   years for every single test run (or more), and hence this approach is not scalable. 

	Thier Extended Test Class

		class TestCircleArea(unittest.TestCase):
			def test_area
			# test area for valid area values

			def test_value
			# make sure value error are raised when neccessary

			def test_types
			# type error is raised when neccessary

	What I think about thier test function:

		1/ The test names are not descriptive at all, and the comments seem redundant, especially since they are using
		   the unittest module, where only the test name and a pass/fail is recorded, and hence, why would the function
		   name not be more documentative?
		2/ It is good that they seperated the different types of testing, although I prefer to go one step further and
		   seperate positive testing from negative testing, but atleast they had sepearation in the testing at all

    "You typically put the testing classes in a different file"

    *Things suddenly got a lot more colloquial becuase I got tired. 
    I disagree with this approach, for the sole reason that when you seperate things, they tend to drift further and further apart
    over time, and there is the tendency to lose the tests, or only copy over the module file and not the test file in a rush say.

    However, once functional advantage of doing so is the ability to use unittest's test discovery,so that you can run all the
    tests from the main project directory with a single commmand. 


#END