
MODULE REPORT
-------------------------------
Python Module: Board (board.py)

-------------------------
Generic Design Decisions:
-------------------------

	1. Headings

		1.0 Introduction
		
		Heading are used in order to quickly identify the different sections of code, for a number of reasons:
			1/ The reader can quickly grasp an idea of the overall structure of the module.
			2/ The reader can quickly scroll to and find the sections they are looking for. 
			3/ The reader can quickly gain an understanding of the different sizes of different sections
			   (This is important to make informed estimations on the effort required for refactoring the modules)
		Heading are implemented as comments for a number of reasons:
			1/ We are trying to seperate the idea of what is 'higher level' from the code, and text editors use of
			   a faded colour scheme helps to achieve that
			2/ On a lower level, we are trying to imply that the structeral is not part of the code

		1.1 Imports
		
		Imports are important to clarify in modular programming, but they specify what the current module is being
		built on. These can also be seen as the modules 'depedencies'
		From an automatic processing perspective, this also means that we can pull out a class heirarchy diagram. This
		task is still not as simple as it could be though, since imports are not very specific in Python, and nor are
		they forced to be. So on top of what Python requires, we add the hueristic that we should make imports as specific
    	as we can, so that we can automitcally pull (anbd ourselves) understand the 'class heirarchy'.
		This also tells us how much we should look for in our code, as well as the functions we have not personally tested, and hence should be wary of.

		1.2 Implementation
		
		This section identifies the implementation of the module in question. We want to quickly indentify this section
		of code, since this is the section we want to read and refactor in general. All other sections can be considered
		auxillary to this section. 

		FOR US: They should be able to find this immediately searching visually only for a single keyword, and not the
		sections of code.

		1.3 Testing Implementation

			1.3.1 The Testing Implementation
			
			This section should be immediately identifiable for 2 reasons:
				1/ We should immediately be able to discern it from implementation code, so that we know when to stop
				2/ We should be able to find the testing immedaitely upon testing failure so we know what went wrong

			1.3.2 Positive Testing
			
			We seperate the positive testing code from the negative testing code, for 2 reasons:
				1/ We want to seperate the mindset, to make sure we remember to do both
				2/ We also want to seperate the mindset, so that you arent switching between the two perspectives 

			1.3.3 Negative Testing
			(The same reason as above)

		1.4 Testing Driver
		
		This identifies code that operates the testing harness. This should also be immediately identifiable, since
		if we want to change the testing flags to give ourselves more testing flexability later, or take some away,
		or we are importing someone elses testing code, and we want to wrap it to our own external framework, this
		would be the exact section we should be looking for the change

		1.5 Concluding Remarks

		One of the byproducts of using headings for the different sections is that it causes a streamlining of the mindset
		that means:
			1/ Programmers should be thinking to include all of these sections
			2/ Instead of different sections bleeding over each other, this encourages sections to be kept
			   for thier original purpose.

		This means that code sections are being kept for a single purpose and a single purpose only, so that not
		only will we know where to find everything (and also, identify when it is not there!), we also can 
		focus on single tasks at a time.

	2. Implementation Section Decisions

		2.1 Class Variables as Constants

		Constants are variables that do not change that are used throughout the code. To try to express that they are
		shared by all instancs of the class, we have implemented them as 'class attributes'.
		These are neccessary because they mean that constants that will be used in things such as testing, we
		can attach meaning to them (since for testing, readability is everything)

		It should be noted that outside of testing they should not be used. The very nature of testing means that
		(in order to avoid circular dependencies in testing) we are often reaching through things. We we are focussing
		on in testing, is readability.

		However, in order to best support real data encapsulation, everything on an object should be done through 
		methods, and hence through the functional code, these attributes should not be used.

		To avoid duplication, it is only because they are shared by many testing classes that we put them in the
		implementation class.

		Otherwise, (I almost forgot) they are also used internally, where there is no problem with breaking encapsulation.

		2.2 Preconditions

		These type of conditions are a grey area business, in the sense that per project, there are different
		classes of occasions that classify as preconditions.

		The classes of values that should be picked up with a precondition error should be identified per project, per module.
		As a whole though, preconditions are an implementation of the 'design by contract' philosophy. The reason we have
		chosen to include this at the error level is:
			1/ Since when we interface we code, we can make mistake, and the worst debugging nightmare in the world is when
			   these errors travel 'invisibly'
			2/ When we write our own code and test it, we want to make sure the values that shouldn't occur, don't occur, and
			   for this, it is important that we have an explicit and consistent error type we can check.
			   (This just basically makes the negative testing easier to code)

		In summary, given the complexity of systems in modern times, invisible errors are alot more trouble than they are worth.

		2.3 Function Descriptions

		In Python, for us, we have made the design decision to include the function documentation within the function. The reason
		for this is that it takes advantave of pythons internal documentation features, such as 'docstring'. The alternative
		that is the next most viable is to put the function documentation above the function. This does not make much of a difference,
		so we stick with the former since it offers the slight advantage.

		The next design decision with function descriptions is what to include. There are 3 essential parts to this, and this
		comes from two perspectives to finalize this:
			1/ What do we need to know in order to use the function (API PERSPECTIVE)
			2/ What is the meta information associated with the function (META PERSPECTIVE)

		The final piece of the puzzle is what the hueristic is for how much we want to include. We choose to include as little as possible. 
		Any extra details only add unneccessary complexity, and extra to be read and confused, as well as kept track of and up to date.
		We want the minimal amount: ("As minimal and simple as we can write them")
			1/ For fast reading and comprehension
			2/ For ease of update
			3/ Ends up writing the code faster too, although this should NOT be a primary concern

		So we include a description, for the meta-perspective, as well as the possible parameters and returns, from the API-perspective.

		2.4 Private Methods and Instances

		Python does not at the language level support private instance variables, and private instances, nor does it provide an easy
		way to enforce such a thing (it would probably be easier just to write a new Turing-complete language). So instead we have to 
		make do with a convention to implement such things.

		The reason that we need private methods and instances is that we want to complete the idea of an object as much as possible. To this
		end, we want instance variables and methods that are only avaliable to its own instance. 

		2.5 Further Considerations

			2.5.1 While Loops vs. For Loops
			
			We use these differently in order to imply intent through our code, even though they can both be used in a relatively similar
			fashion to achieve the same functionality.

			We use while loops for a loop where the condition is the most important aspect, and the result of this condition is what we want
			to focus on. I.e in 'board.py', we choose to use a while loop for the index when we are looping through the column elements of the
			board. This is because we want to focus on the condition that we have not reached the maximum index

			We use for loops for when we want to focus on what we are iterating over. This is the case, for example, when we are iterating
			over an array to proces all of the elements contained.

			The most important aspect when we read a line that introduces a scope is how much context that lines gives us, and we can use these
			distinctions to imply intent in the control flow

			2.5.2 The End Of A Function

			One problem with scoping in python is that due to all scoping having the same indentation rule, visually identifying where a
			function ends is difficult, or atleast, not immediate.

			In order to address this, we sacrifice one line to include '#END' as a comment, in the same indentation as the function signature
			line.

			2.5.3 Preconditions on the Instance Type

			One of the greatest advantages of the Python programming language is the ability to Duck Type. This means that we can reuse
			functions for any type that can make it through the sequence of operations without error.

			This causes a fundemental problem though, with 'silent errors'. We can reuse a functions for any type that works, but what happens
			if the function doesn't through an error, but doesn't work as required either. This error would be picked up in testing, but
			even testing is never perfect, and how would you know testing has been done for values of this type?

			Alot of these questions can be answered with the idea of using an 'instance type' precondition for the function. These mean
			that we will never use a new type and just allow for this level of invisible errors to flow through, and we can also write
			in a new instance for a new type in the preconditions when we have done testing for that type, so that the function
			preconditions also document what testing has been done for which types. 

	3. Testing Implementation Decisions

		3.0 Introduction

		Testing is a crucial part of the module creation process, and without testing, usage of module code is unsafe. Testing is there to provide
		assurances the module is (to some degree) correct.

		Testing itself has several functions:
			1/ It provides assurances that the module provides the functionality that it says it will provide (abides by API contract)
			2/ It provides assurances of what functionality will occur upon error in the interface arguements applied to the module
			3/ It provides some documentation on how the module can be used, in the case of both correct use, and when error occur.

		Testing code itself is also written in a slightly different style to the functional code. With testing code, the two biggest focusses are:
			1/ Granularity
			2/ Readability

		These two features are greatly focussed on in functional code too, but in a different way.

			*Reading this section by itself or searching for it within document means we may want this extra context, even though in its entirety is implicit
			3.0.1 Granularity in Testing

			*It feels like the level of knowledge explained and assumed by the reader is making an abrupt change here
			Granularity in testing is about splitting up test cases as much as is practically possible. This means writing test cases for as
			many seperate cases as possible, as well as only testing a single aspect, and making this aspect as low level as possible.

			The reason that we want granularity in testing is for two reasons:
				
				1/ One is for the same reason we use a finer comb to search for lice in hair. Sometimes error hide in small nooks and crannies
				   within functions, and we need testing that reaches into the different aspects and areas of a functions to find these unsuspecting
				   and very novel cases that cause an error
				
				2/ It means that when we do find an error, we have alot more information regarding it, and surrounding it, than if we just called
				   a single complex function and shoved through all the possible values, and got an error then. In the latter case, we have no more
				   information other than the entire function failed on a certain input. In more granular testing, we would be testing aspects of the
				   function seperately in different ways, so that when an error occurs, we have more information about where in the function or in
				   what aspect of the function that the input is causing a failure.

			3.0.2 Readability in Testing

			Readability is testing is also extremely important in the sense that we are trying to express (for every error found) as much about that
			error as possible.

			When we find an error the next thing we want to do is find exactly what is causing it, and fix that cause, and the more information that
			we have to accomplish this, the better.

		3.1 Using UnitTest FrameWork

		This framework has been chosen, since for testing our modules we want a framework that is both expressive, and flexible, to give us options
		on our testing style.

		Unit test has a few great advantages:

			1/ Test Discovery:

			Instead of having to write a testing script that traverses through directories ourselves, and looks for the unit tests within modules,
			we use 'test discovery', so that from our base project directory, we can run all testing with a single command.

			This is extremely important, as the simpler and easier it is to run tests, the more likely they will be run often (or even at all).

			2/ Test Method Discovery:

			In test classes, without this framework we would have to write a testing wrapper class that instantiated all of the internal testing
			classes, and then called all of thier methods. When we wrote a new testing method in to test a new aspect of the function, or take
			one away, this would also need to be added, or removed, from the base testing class in the module. 

			With the UnitTest framework, test method discovery means that we only need to write the methods, or remove them, and the framework
			will handle thier discovery, execution, and result reporting. 

		3.2 Testing Classes

		For each method that we write in a class, and for each function that we write in a module, we create a seperate testing class that is
		named in association to the name of the function or method.

		When we write tests, we are also aiming for readability in the code we are writing aswell, and too much testing in the same class clutters
		the information, and makes searching for specific information within the class more difficult. 

		*Here we are addressing the other option
		We also dont want to seperate out the information too much, and test a single function across multiple test classes, because then for
		finding and deciphering information for a single function or method means reading multiple classes and putting the information together. 

		So the best approach given these considerations is one test class per function/method. Each class should have instances that reflect
		the key information that will be needed across the tests, such as invalid and valid testing arguement values for the method/function.

		3.3 Testing Methods

		Testing methods should be designed to test one and only one aspect of the function per method. This implies that we should also
		only have one assert statement per test method, since multiple would mean we are probably testing more than a single aspect.

		The aspect that we are testing should be described in the name for two reasons:
			1/ We have already specified the method we are testing in the class name
			2/ The UnitTest framework that we are using uses this name when reporting the status of the method, so it also documents the test

		We split methods into two sections, one for 'positive' testing, and the other for 'negative testing'.
		*Here I made a decision to use 'the other' to imply both how it is connected and also that we have complete coverage of cases

			3.3.1 Positive Testing Methods

			These are testing methods that we use to test the correct functionality of the method/function when applied to valid arguements.
			These test that the 'black box' gives correct outputs based on correct inputs, and will largely consist of 'assertEqual' statements.

			These tests are split into tests at the begining that test basic functionality, then further testing methods explore the nooks
			and crannies of the function.

			3.3.2 Negative Testing Methods

			Negative methods test the operation of the function given invalid inputs. Although a function should never be given invalid arguements, 
			in practice this does occur sometimes for a number of reasons. The most important thing is that 'silent errors' are one of the most
			difficult things to debug, because they travel 'silently' for a while before they are picked up, and remove the error location from the
			cause. 

			In order to address the issue, we have negative testing in order to:
				1/ Document what happens when the method/function is given invalid values
				2/ Make sure that invalid values expected to cause errors, cause errors.

--------------------------
Specific Design Decisions:
--------------------------

	1. Specific Decisions in Implementation

		1.1 Token Value Implementation

		Currently, the token value implementation consists of the lines:
		    EMPTY_VALUE = 0
    		PLAYER_TOKEN_VALUE = [1, 2]

    	There are a couple of issues here:
    		1/ It seperates two sections of token values. What this means is that you can change one without even looking at the other,
    		   but these ideas are connected, and should be in our code too, so we want to include them in a single line so that changing
    		   one has to be done surrounded by the other
    		2/ We have implemented the PLAYER_TOKEN_VALUE as an array, which we index with 0 and 1, although the player numbers are 1 and 2.
    		   This means that when we index given the player number we have to move the player number. This conversion can cause problems
    		   2.1/ since it can be easily forgotten
    		   2.2/ reading it in the code also makes no immediate sense

    	First Alternative:
    		The problem could be fixed by having an encompassing array, TOKEN_VALUE, that takes the three, which solves the problem
    		by 'coincidence', since this would also fix the player indexing issue aswell.

    		However, given that this solves the issue by coincidence, this opens up issues for later, since a programmer making changes to
    		this game such as no empty values, might alter this and break our logic without realizing

    	Second Alternative:
    		A Python dictionary could be used:

				TOKEN_VALUE = {
 					"EmptyValue": 0,
  					1: 1,
  					2: 2
  				}

  			And the greatest thing about the dictionary is that it can contain multiple types, since we want to refer to the player
  			numbers with integers internally, since that is how they will be passed in from the external boundary, as well as we can
  			keep the empty value identifier as a string, in order to convey what it is.

  			Coming at this from a refactoring and extension perspective, it also allows change with the grouping information class at
  			hand, as well as the ability to extend the tokens without affecting the existing code (which is always the goal with changes
  			to be made).

  		1.2 The '_create_column_of_empty_value' Method

  		For this method I considered removing it from the class and placing it above in an auxillary function section. The main reaons
  		I considered doing this centered around trying to declutter class code by removing functions if they were not directly coupled
  		to the idea of the class. 

  		However, I saw a few problems with this:
  			1/ When reading the code we know have to look for away to find the relevant functions
  			2/ We have to check two sections for every function, since it will not be immediately obvious which section the operation shouls
  			   be in
  		
  		Thus, I decided to leave the function within class code, NOT DOCUMENT IT, and give it the '_' prefix convention for private functions.

  		A second design decision was to include the building of the array as an operation that continously appends the correct element to the
  		array. I realize there may be a shortcut for this, but I like to write code in ways that can span across multiple languages, so
  		that I can test them, empirically understand thier operation, and learn lessons that can be applied later. 

  		This last consideration, instead of being about the exact code I am writing at the time, is in consideration to all code that
  		I will be writing in the future, which is a concern I personally think many programmers forget. 

  		1.3 The 'getBoardAsString' Method

  		The first thing people would notice looking at this method is probably the structeral observation that is contains multiple
  		nested scopes. Multiple nested scopes can be difficult to read, since it requires while reading to keep track of the different
  		possible control flows.

  		The second observation that would probably be made while reading the function is that it is formatted the string in a way
  		that provides no real information why each decision is being made, or even what the end product would look like. 

  		To address the first issue, we will first refactor out a function:

            def getBoardAsString(self):
            boardString = "\n_______\n"
            for boardXPosition in range(Board.BOARD_SIZE):
   	            for boardYPosition in range(Board.BOARD_SIZE):
   	                if self._boardGrid[boardXPosition][boardYPosition] == Board.EMPTY_VALUE:
   	                    boardString += "| "
   	                if self._boardGrid[boardXPosition][boardYPosition] == Board.PLAYER_TOKEN_VALUE[0]:
   	                    boardString += "|"+Board.PLAYER_ONE_SYMBOL
   	                if self._boardGrid[boardXPosition][boardYPosition] == Board.PLAYER_TOKEN_VALUE[1]:
	                    boardString += "|"+Board.PLAYER_TWO_SYMBOL   

            	boardString += "|\n"
        	boardString += "_______\n"
        	return boardString

        to:

        	*Dont try to really name a function before you know whats going on....
        	def _add_board_string_symbols

            def getBoardAsString(self):
            boardString = "\n_______\n"
            for boardXPosition in range(Board.BOARD_SIZE):
   	            for boardYPosition in range(Board.BOARD_SIZE):
   	                if self._boardGrid[boardXPosition][boardYPosition] == Board.EMPTY_VALUE:
   	                    boardString += "| "
   	                if self._boardGrid[boardXPosition][boardYPosition] == Board.PLAYER_TOKEN_VALUE[0]:
   	                    boardString += "|"+Board.PLAYER_ONE_SYMBOL
   	                if self._boardGrid[boardXPosition][boardYPosition] == Board.PLAYER_TOKEN_VALUE[1]:
	                    boardString += "|"+Board.PLAYER_TWO_SYMBOL   

            	boardString += "|\n"
        	boardString += "_______\n"
        	return boardString









