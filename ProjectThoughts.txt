
My Thoughts On The Tic Tac Toe Project
--------------------------------------

---
Main Application Module
---

	1. Test Arguements

	This main module needs to be the single module in the project that distinguishes between running as a test, and
	running as production.

	We label all such application modules with the suffix 'Application', to make this obvious.

	2. The Application Main Script

		2.1 Logging

		If logging is included in an application, the first global task is to intiate logging for all modules

		2.2 Arguement Parsing

		For command line arguements, this is where we make transformation on those arguements, so that we can send
		them to sub modules where necessary, and also take into account the different application executions that
		these arguements may signify.

	3. Structure

	After setup, the application module is responsible for:
		1. The instantiation of all submodule objects
		2. Setting up communication between all submodule objects
		3. Running a main application loop

---
Testing Considerations
---

	1.0 Testing Operandi

	We push for automation in testing as much as possible. This is because the more a person has to do to test, the less
	likely they are to run them often, or at all.

	3 Levels Of Testing Interaction:
		1/ When we want to automate and run tests before compilation where all we care about is that we get an okay,
		   as these are what SHOULD be run most often
		2/ Printed result tests, so that what is going on can be read and interpreted. These give more information, and are
		   extremely useful during development
		3/ Testing that involves user interaction. As these will be the slowest tests to run, these will probably be run
		   the least often.

	       These should provide two sets of messages, telling the user:
	        	3.1/ What to do
	        	3.2/ What to expect
	        	*Optionally, you can also have a checkbox to record the result, although this is going to be imperfect.

---
Classes
---

	*The spread of the layers of abstraction (tree like) is also important because a stretched tree also stretches understanding

	1.0 Board Command

		1.1 Multiple Constructor

		Instead of bothering with inheritance, given that the game is not going to expand, as well as fact that class code
		will probably remain low in character count (famous last words), all commands will be implemented in this single
		class, with multiple constructors. 

		What we can do is use static constructor methods to hide alot of the inner details, and then this could become
		a factor for other classes later (if neccessary).

		1.2 A Second Alternative To Multiple Constructor

		An alternative to multiple constructors is to have a constant arguement that is passed to the constructor.
		(Since Python is not typed AT ALL, this is actually very possible.)

		init(self.PLAYER_MOVE)
		init(self.PRINT_BOARD)
		then self.executeCommandOnBoard.

		1.3 Seperating The Board From The Command

		This design decision was made for several reasons:
			1/ We may want to perform the same command on multiple board.
			2/ If we are playing this game over a network, we may not have access to the board of command creation.

		In light of these issues, the board has been decoupled from the command creation.

		1.4 NOT Having a Direct Print Board Command

		This decision was made so that the only class that needs to understand the board, is the Command Class. This
		is an attempt to reduce the interface depedencies within our system, which may halt changes to our system
		in the future that we have not anticipated now.

		



	2.0 User Panel

		2.1 Exceptions

		Firstly, we dont exceptions on input of invalid commands, because there is no reason to stop the game, and we
		should probably just let them keep going. 

		2.2 Inheritance

		This class could inherit as a 'source', so that this source could be switched out with something that wraps a
		socket when we perform that extension ('an example of programming for the future').
